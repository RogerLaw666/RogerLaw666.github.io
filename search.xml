<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>curl的基本使用</title>
    <url>/2020/11/15/curl%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/curl_title.png" alt="curl"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>curl - transfer a URL</p>
<p>cURL 是一个利用 URL 语法在命令行下工作的文件传输工具，1997 年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称 cURL 为下载工具。cURL 还包含了用于程序开发的 libcurl。</p>
<p>cURL 支持的通信协议有 FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP 和 RTSP。</p>
<p>curl 还支持 SSL 认证、HTTP POST、HTTP PUT、FTP 上传, HTTP form based upload、proxies、HTTP/2、cookies、用户名+密码认证(Basic, Plain, Digest, CRAM-MD5, NTLM, Negotiate and Kerberos)、file transfer resume、proxy tunneling。</p>
<a id="more"></a>

<h2 id="curl-的示例"><a href="#curl-的示例" class="headerlink" title="curl 的示例"></a>curl 的示例</h2><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get</span></span><br><span class="line">curl <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="http-版本"><a href="#http-版本" class="headerlink" title="http 版本"></a>http 版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HTTP/1.0</span></span><br><span class="line">curl -0 <span class="variable">$url</span></span><br><span class="line"><span class="comment"># HTTP/1.1</span></span><br><span class="line">curl -1 <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="返回压缩的格式"><a href="#返回压缩的格式" class="headerlink" title="返回压缩的格式"></a>返回压缩的格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --compressed <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -A <span class="string">&quot;I&#x27;m your father&quot;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="来源网址"><a href="#来源网址" class="headerlink" title="来源网址"></a>来源网址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -e <span class="variable">$referer_url</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="发送-header-到服务器"><a href="#发送-header-到服务器" class="headerlink" title="发送 header 到服务器"></a>发送 header 到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="保存至本地"><a href="#保存至本地" class="headerlink" title="保存至本地"></a>保存至本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="另存为本地某个文件"><a href="#另存为本地某个文件" class="headerlink" title="另存为本地某个文件"></a>另存为本地某个文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o <span class="variable">$save_to_file</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="发送-cookie"><a href="#发送-cookie" class="headerlink" title="发送 cookie"></a>发送 cookie</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b <span class="string">&#x27;foo1=bar;foo2=bar2&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="发送本地-cookie-文件到服务器"><a href="#发送本地-cookie-文件到服务器" class="headerlink" title="发送本地 cookie 文件到服务器"></a>发送本地 cookie 文件到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -b cookies.txt <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="获取服务器-cookie-并保存到本地"><a href="#获取服务器-cookie-并保存到本地" class="headerlink" title="获取服务器 cookie 并保存到本地"></a>获取服务器 cookie 并保存到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -c cookies.txt <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="post-方法"><a href="#post-方法" class="headerlink" title="post 方法"></a>post 方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;name=roger＆age=18&#x27;</span> -X POST <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="用-post-方法发送本地文件到服务器"><a href="#用-post-方法发送本地文件到服务器" class="headerlink" title="用 post 方法发送本地文件到服务器"></a>用 post 方法发送本地文件到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;@data.txt&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="用-get-方法发送数据到服务器"><a href="#用-get-方法发送数据到服务器" class="headerlink" title="用 get 方法发送数据到服务器"></a>用 get 方法发送数据到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -G -d <span class="string">&#x27;name=roger&#x27;</span> -d <span class="string">&#x27;age=18&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="用指定方法发送数据"><a href="#用指定方法发送数据" class="headerlink" title="用指定方法发送数据"></a>用指定方法发送数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X POST <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="发送文件到服务器"><a href="#发送文件到服务器" class="headerlink" title="发送文件到服务器"></a>发送文件到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -F <span class="string">&#x27;file=@photo.png;filename=me.png&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="发送-json-到服务器"><a href="#发送-json-到服务器" class="headerlink" title="发送 json 到服务器"></a>发送 json 到服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;name&quot;: &quot;roger&quot;, &quot;age&quot;: &quot;18&quot;&#125;&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="从服务器获取-header-和资源"><a href="#从服务器获取-header-和资源" class="headerlink" title="从服务器获取 header 和资源"></a>从服务器获取 header 和资源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -i <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="仅从服务器获取-header"><a href="#仅从服务器获取-header" class="headerlink" title="仅从服务器获取 header"></a>仅从服务器获取 header</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -I <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="忽略-ssl"><a href="#忽略-ssl" class="headerlink" title="忽略 ssl"></a>忽略 ssl</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="跟随重定向"><a href="#跟随重定向" class="headerlink" title="跟随重定向"></a>跟随重定向</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L -d <span class="string">&#x27;name=roger&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="设置传输速度"><a href="#设置传输速度" class="headerlink" title="设置传输速度"></a>设置传输速度</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --limit-rate 200k <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="静默模式"><a href="#静默模式" class="headerlink" title="静默模式"></a>静默模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="显示错误信息"><a href="#显示错误信息" class="headerlink" title="显示错误信息"></a>显示错误信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -S <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="登陆服务器"><a href="#登陆服务器" class="headerlink" title="登陆服务器"></a>登陆服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -u <span class="string">&#x27;name:passwd&#x27;</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="冗余模式"><a href="#冗余模式" class="headerlink" title="冗余模式"></a>冗余模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="跟踪数据"><a href="#跟踪数据" class="headerlink" title="跟踪数据"></a>跟踪数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --trace - <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="用代理发送数据"><a href="#用代理发送数据" class="headerlink" title="用代理发送数据"></a>用代理发送数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -x socks5://name:passwd@myproxy.com:8080 <span class="variable">$url</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>curl</tag>
        <tag>linux</tag>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title>awk的基本使用</title>
    <url>/2020/11/03/awk%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/awk_title.png" alt="awk"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AWK - pattern scanning and text processing language</p>
<p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<p>之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>
<a id="more"></a>

<h2 id="awk-的语法格式"><a href="#awk-的语法格式" class="headerlink" title="awk 的语法格式"></a>awk 的语法格式</h2><h3 id="program-PATTERN-ACTION-STATEMENTS"><a href="#program-PATTERN-ACTION-STATEMENTS" class="headerlink" title="program: PATTERN{ACTION STATEMENTS}"></a>program: PATTERN{ACTION STATEMENTS}</h3><ul>
<li>语句之间用分号分隔</li>
<li>print, printf</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li>-F: 指明输入时用到的字段分隔符</li>
<li>-v: var=value: 自定义变量</li>
</ul>
<h2 id="awk-的具体语法"><a href="#awk-的具体语法" class="headerlink" title="awk 的具体语法"></a>awk 的具体语法</h2><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><h4 id="print-的语法"><a href="#print-的语法" class="headerlink" title="print 的语法"></a>print 的语法</h4><p>print item1, item2, …</p>
<h4 id="print-的要点"><a href="#print-的要点" class="headerlink" title="print 的要点"></a>print 的要点</h4><ul>
<li>逗号分隔符</li>
<li>输出的各 item 可以字符串，也可以是数值，当前记录的字段、变量或 awk 的表达式</li>
<li>如省略 item，相当于 print $0</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h4><ul>
<li><p>FS: input field seperator，默认为空白字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -v FS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>OFS: output field seperator，默认为空白字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -v OFS=<span class="string">&#x27;-&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>RS: input record seperator，输入时的换行符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -v RS=<span class="string">&#x27;\r\n&#x27;</span> <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>ORS: output record seperator，输出时的换行符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -v ORS=<span class="string">&#x27;-----&#x27;</span> <span class="string">&#x27;&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>NF: number of field，字段数量</p>
<ul>
<li>{print NF}: 每行的字段数量</li>
<li>{print $NF}: 每行的最后一个字段</li>
</ul>
</li>
<li><p>NR: number of record, 行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print NR,$0&#125;&#x27;</span> /etc/passwd /etc/issue</span><br></pre></td></tr></table></figure>
</li>
<li><p>FNR: 各文件分别计数，行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print FNR,$0&#125;&#x27;</span> /etc/passwd /etc/issue</span><br></pre></td></tr></table></figure>
</li>
<li><p>FILENAME: 当前文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print FILENAME,$0&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>ARGC: 命令行参数的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print ARGC&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>ARGV: 数组，保存的是命令行所给定的各参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># awk, /etc/passwd</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print ARGV[0]&#125;&#x27;</span> /etc/passwd</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print ARGV[1]&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><ul>
<li><p>-v var=value</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -v MY_NAME=<span class="string">&#x27;roger&#x27;</span> <span class="string">&#x27;BEGIN &#123;print MY_NAME&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量名区分字符大小写</li>
</ul>
</li>
<li><p>在 program 中直接定义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;MY_NAME=&quot;roger&quot;;print MY_NAME&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="printf-命令"><a href="#printf-命令" class="headerlink" title="printf 命令"></a>printf 命令</h3><h4 id="printf-的语法"><a href="#printf-的语法" class="headerlink" title="printf 的语法"></a>printf 的语法</h4><p>printf FORMAT, item1, item2, …</p>
<h4 id="printf-的要点"><a href="#printf-的要点" class="headerlink" title="printf 的要点"></a>printf 的要点</h4><ul>
<li><p>FORMAT 必须给出</p>
</li>
<li><p>不会自动换行，需要显式给出换行控制符，\n</p>
</li>
<li><p>FORMAT 中需要分别为后面的每个 item 指定一个格式化符号</p>
</li>
<li><p>格式符:</p>
<ul>
<li>%c: 显示字符的 ASCII 码</li>
<li>%d, %i: 显示十进制整数</li>
<li>%e, %E: 科学计数法数值显示</li>
<li>%f: 显示为浮点数</li>
<li>%g, %G: 以科学计数法或浮点形式显示数值</li>
<li>%s: 显示字符串</li>
<li>%u: 无符号整数</li>
<li>%%: 显示%自身</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;printf &quot;%s\n&quot;,&quot;roger&quot;&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰符:</p>
<ul>
<li>#[.#]: 第一个数字控制显示的宽度，第二个#表示小数点后的精度<ul>
<li>%3.1f</li>
</ul>
</li>
<li>-: 左对齐</li>
<li>+: 显示数值的符号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;printf &quot;username: %15s\n&quot;,$1&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h4><ul>
<li>x+y, x-y, x*y, x/y, x^y, x%y</li>
<li>-x</li>
<li>+x: 转换为数值</li>
</ul>
<h4 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h4><p>没有符号的操作符，字符串连接。</p>
<h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><ul>
<li>=, +=, -=, *=, /=, %=, ^=</li>
<li>++, –</li>
</ul>
<h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><ul>
<li>&gt;, &gt;=, &lt;, &lt;=, !=, ==</li>
</ul>
<h4 id="模式匹配符"><a href="#模式匹配符" class="headerlink" title="模式匹配符"></a>模式匹配符</h4><ul>
<li>~: 是否匹配</li>
<li>!~: 是否不匹配</li>
</ul>
<h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h4><ul>
<li>&amp;&amp;</li>
<li>||</li>
<li>!</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><ul>
<li>function_name(argu1, argu2, …)</li>
</ul>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">selector?if-true-expression:if-false-expression</span><br><span class="line"></span><br><span class="line">awk -F: <span class="string">&#x27;&#123;$3&gt;=1000?usertype=&quot;Common User&quot;:usertype=&quot;Sysadmin or SysUser&quot;;printf &quot;%15s:%-s\n&quot;,$1,usertype&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>空模式，匹配每一行。</p>
<h4 id="regular-expression"><a href="#regular-expression" class="headerlink" title="/regular expression/"></a>/regular expression/</h4><p>仅处理能够被此处的模式匹配到的行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;!/(^#|^$)/&#123;print $0&#125;&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>

<h4 id="relational-expression"><a href="#relational-expression" class="headerlink" title="relational expression"></a>relational expression</h4><p>关系表达式，结果有“真”有“假”，结果为“真”才会被处理。</p>
<p>真: 结果为非 0 值，非空字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;$3&gt;=1000&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;$NF~/\/bin\/bash$/&#123;print $1,$NF&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h4 id="line-ranges-行范围"><a href="#line-ranges-行范围" class="headerlink" title="line ranges: 行范围"></a>line ranges: 行范围</h4><ul>
<li>startline,endline: /pat1/,/pat2/</li>
<li>注意: 不支持直接给出数字的格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;(NR&gt;=2&amp;&amp;NR&lt;=10)&#123;print $1&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h4 id="BEGIN-END-模式"><a href="#BEGIN-END-模式" class="headerlink" title="BEGIN/END 模式"></a>BEGIN/END 模式</h4><ul>
<li><p>BEGIN{}: 仅在开始处理文件中的文本之前执行一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;sum=0;for(i=0;i&lt;=100;i++)&#123;sum+=i&#125;;print sum&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>END{}: 仅在文本处理完成之后执行一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;sum=0;for(i=0;i&lt;=100;i++)&#123;sum+=i&#125;&#125;END&#123;print sum&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="常用的-action"><a href="#常用的-action" class="headerlink" title="常用的 action"></a>常用的 action</h3><ul>
<li>Expressions</li>
<li>Control statements: if, while 等</li>
<li>Compound statements: 组合语句</li>
<li>input statements</li>
<li>output statements</li>
</ul>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition) &#123;statments&#125;</span><br><span class="line"><span class="keyword">if</span>(condition) &#123;statments&#125; <span class="keyword">else</span> &#123;statements&#125;</span><br><span class="line"><span class="keyword">while</span>(conditon) &#123;statments&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;statements&#125; <span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">for</span>(expr1;expr2;expr3) &#123;statements&#125;</span><br><span class="line"><span class="built_in">break</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">delete array[index]</span><br><span class="line">delete array</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">&#123; statements &#125;</span><br></pre></td></tr></table></figure>

<h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:<span class="keyword">if</span>(condition) statement [<span class="keyword">else</span> statement]</span><br><span class="line"></span><br><span class="line">awk -f: <span class="string">&#x27;&#123;if($3&gt;=1000) &#123;printf &quot;common user: %s\n&quot;,$1&#125; else &#123;printf &quot;root or sysuser: %s\n&quot;,$1&#125;&#125;&#x27;</span> /etc/passwd</span><br><span class="line">awk -f: <span class="string">&#x27;&#123;if($NF==&quot;/bin/bash&quot;) print $1&#125;&#x27;</span> /etc/passwd</span><br><span class="line">awk <span class="string">&#x27;&#123;if(NF&gt;5) print $0&#125;&#x27;</span> /etc/fstab</span><br><span class="line">df -h | awk -F% <span class="string">&#x27;/^\/dev/&#123;print $1&#125;&#x27;</span> | awk <span class="string">&#x27;&#123;if($NF&gt;=20) print $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用场景: 对 awk 取得的整行或某个字段做条件判断。</p>
<h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:<span class="keyword">while</span>(condition) statement</span><br></pre></td></tr></table></figure>

<p>条件“真”，进入循环，条件“假”，退出循环。</p>
<p>使用场景: 对一行内的多个字段逐一类似处理时使用，对数组中的各元素逐一处理时使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;print $i,length($i); i++&#125;&#125;&#x27;</span> /etc/grub2.cfg</span><br><span class="line">awk <span class="string">&#x27;/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF) &#123;if(length($i)&gt;=7) &#123;print $i,length($i)&#125;; i++&#125;&#125;&#x27;</span> /etc/grub2.cfg</span><br></pre></td></tr></table></figure>

<h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:<span class="keyword">do</span> statement <span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>

<p>意义: 至少执行一次循环体。</p>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:<span class="keyword">for</span> (expr1;expr2;expr3) statement</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(variable assignment;condition;iteration process) &#123;for-body&#125;</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/^[[:space:]]*linux16/&#123;for(i=1;i&lt;=NF;i++) &#123;print $i,length($i)&#125;&#125;&#x27;</span> /etc/grub2.cfg</span><br></pre></td></tr></table></figure>

<p>特殊用法: 能够遍历数组中的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:<span class="keyword">for</span>(var <span class="keyword">in</span> array) &#123;for-body&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法:switch(expression) &#123;<span class="keyword">case</span> value1 or /regexp/: statement; <span class="keyword">case</span> value2 or /regexp2/: statement; ...; default: statement&#125;</span><br></pre></td></tr></table></figure>

<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> [n]</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>提前结束对本行的处理而直接进入下一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;&#123;if($3%2!=0) next; print $1,$3&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="关联数组-array-index-expression"><a href="#关联数组-array-index-expression" class="headerlink" title="关联数组: array[index-expression]"></a>关联数组: array[index-expression]</h4><p>其中 index-expression 需要注意的地方:</p>
<ul>
<li>可使用任意字符串，字符串要使用双引号</li>
<li>如果某数组元素事先不存在，在引用时，awk 会自动创建此元素，并将其值初始化为“空串”</li>
<li>若要判断数组中是否存在某元素，要使用”index in array”格式进行</li>
<li>weekdays[“mon”]=”Monday”</li>
</ul>
<p>若要遍历数组中的每个元素，要使用 for 循环:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(var <span class="keyword">in</span> array) &#123;for-body&#125;</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;weekdays[&quot;mon&quot;]=&quot;Monday&quot;;weekdays[&quot;tue&quot;]=&quot;Tuesday&quot;;for(i in weekdays) &#123;print weekdays[i]&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;arr[&quot;a&quot;]=1;arr[&quot;b&quot;]=2;for (a in arr) &#123;print a&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意 : var 会遍历 array 的每个索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">state[<span class="string">&quot;LISTEN&quot;</span>]++</span><br><span class="line">state[<span class="string">&quot;ESTABLISHED&quot;</span>]++</span><br><span class="line"></span><br><span class="line">netstat -tan | awk <span class="string">&#x27;/^tcp\&gt;/&#123;state[$NF]++&#125;END&#123;for(i in state) &#123;print i,state[i]&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;&#123;ip[$1]++&#125;END&#123;for(i in ip) &#123;print i,ip[i]&#125;&#125;&#x27;</span> /var/<span class="built_in">log</span>/httpd/access_log</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li><p>统计/etc/fstab 文件中每个文件系统类型出现的次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/^UUID/&#123;fs[$3]+ + &#125;END&#123;for (i in fs) &#123;pr i nt i,fs[i]&#125; &#125; &#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计指定文件中每个单词出现的次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;count[$i]++&#125;&#125;END&#123;for(i in count) &#123;print i,count[i]&#125;&#125;&#x27;</span> /etc/fstab</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数有内置函数和自定义函数之分。</p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><ul>
<li><p>数值处理:</p>
<ul>
<li>rand(): 返回 0 和 1 之间一个随机数</li>
</ul>
</li>
<li><p>字符串处理:</p>
<ul>
<li>length([s]): 返回指定字符串的长度</li>
<li>sub(r,s,[t]): 以 r 表示的模式来查找 t 所表示的字符中的匹配的内容，并将其第一次出现替换为 s 所表示的内容</li>
<li>gsub(r,s,[t]): 以 r 表示的模式来查找 t 所表示的字符中的匹配的内容，并将其所有出现均替换为 s 所表示的内容</li>
<li>split(s,a[,r]): 以 r 为分隔符切割字符 s，并将切割后的结果保存至 a 所表示的数组中，以下标 1 为第一个元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tan | awk <span class="string">&#x27;/^tcp\&gt;/&#123;split($5,ip,&quot;:&quot;);count[ip[1]]++&#125;END&#123;for (i in count) &#123;print i,count[i]&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><h2 id="awk-的示例"><a href="#awk-的示例" class="headerlink" title="awk 的示例"></a>awk 的示例</h2><h3 id="读取外部执行命令的文件来执行命令"><a href="#读取外部执行命令的文件来执行命令" class="headerlink" title="读取外部执行命令的文件来执行命令"></a>读取外部执行命令的文件来执行命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -f <span class="variable">$path_to_script_file</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="打印特定行"><a href="#打印特定行" class="headerlink" title="打印特定行"></a>打印特定行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NR&gt;=1 &amp;&amp; NR&lt;=5) print $0&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br><span class="line">awk -v FS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br><span class="line">awk -v FS=<span class="string">&#x27;:&#x27;</span> -v OFS=<span class="string">&#x27;-&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="开始和结束脚本"><a href="#开始和结束脚本" class="headerlink" title="开始和结束脚本"></a>开始和结束脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;FS=&quot;:&quot;&#125; END &#123;print &quot;end&quot;&#125; &#123;print $1&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="获取-shell-命令参数"><a href="#获取-shell-命令参数" class="headerlink" title="获取 shell 命令参数"></a>获取 shell 命令参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;&quot;&#x27;</span><span class="variable">$1</span><span class="string">&#x27;&quot;&#125;&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl的基本应用</title>
    <url>/2020/11/05/openssl%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/openssl_title.png" alt="openssl"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在计算机网络上，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。</p>
<p>SSL 是 Secure Sockets Layer（安全套接层协议）的缩写，可以在 Internet 上提供秘密性传输。Netscape 公司在推出第一个 Web 浏览器的同时，提出了 SSL 协议标准。其目标是保证两个应用间通信的保密性和可靠性,可在服务器端和用户端同时实现支持。已经成为 Internet 上保密通讯的工业标准。</p>
<p>SSL 能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。SSL 协议要求建立在可靠的传输层协议(TCP)之上。SSL 协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET 等)能透明地建立于 SSL 协议之上。SSL 协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p>
<a id="more"></a>

<h2 id="加密算法和协议"><a href="#加密算法和协议" class="headerlink" title="加密算法和协议"></a>加密算法和协议</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一个密钥。</p>
<h4 id="对称加密的类型"><a href="#对称加密的类型" class="headerlink" title="对称加密的类型"></a>对称加密的类型</h4><ul>
<li>DES: Data Encryption Standard</li>
<li>3DES: Triple DES</li>
<li>AES: Advanced Encryption Standard(128bits, 192bits, 256bits, 384bits)</li>
<li>Blowfish</li>
<li>Twofish</li>
<li>IDEA</li>
<li>RC6</li>
<li>CAST5</li>
</ul>
<h4 id="对称加密的特性"><a href="#对称加密的特性" class="headerlink" title="对称加密的特性"></a>对称加密的特性</h4><ul>
<li>加密、解密使用同一个密钥</li>
<li>将原始数据分割成为固定大小的块，逐个进行加密</li>
</ul>
<h4 id="对称加密的缺陷"><a href="#对称加密的缺陷" class="headerlink" title="对称加密的缺陷"></a>对称加密的缺陷</h4><ul>
<li>密钥过多</li>
<li>密钥分发困难</li>
</ul>
<h3 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h3><p>密钥分为公钥与私钥。</p>
<h4 id="公钥加密的公钥"><a href="#公钥加密的公钥" class="headerlink" title="公钥加密的公钥"></a>公钥加密的公钥</h4><p>从私钥中提取产生，可公开给所有人，也叫 pubkey。</p>
<h4 id="公钥加密的私钥"><a href="#公钥加密的私钥" class="headerlink" title="公钥加密的私钥"></a>公钥加密的私钥</h4><p>通过工具创建，使用者自己留存，必须保证其私密性，也叫 secret key。</p>
<h4 id="公钥加密的特性"><a href="#公钥加密的特性" class="headerlink" title="公钥加密的特性"></a>公钥加密的特性</h4><p>用公钥加密的数据，只能使用与之配对儿的私钥解密，反之亦然。</p>
<h4 id="公钥加密的用途"><a href="#公钥加密的用途" class="headerlink" title="公钥加密的用途"></a>公钥加密的用途</h4><ul>
<li>数字签名: 主要在于让接收方确认发送方的身份</li>
<li>密钥交换: 发送方用对方公钥加密一个对称密钥，并发送给对方</li>
<li>数据加密</li>
</ul>
<h4 id="公钥加密的算法"><a href="#公钥加密的算法" class="headerlink" title="公钥加密的算法"></a>公钥加密的算法</h4><p>RSA，DSA，ELGamal<br>DSS: Digital Signature Standard<br>DSA: Digital Signature Algorithm</p>
<h3 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h3><p>即提出数据指纹，只能加密，不能解密。</p>
<h4 id="单向加密的特性"><a href="#单向加密的特性" class="headerlink" title="单向加密的特性"></a>单向加密的特性</h4><p>定长输出、雪崩效应。</p>
<h4 id="单向加密的功能"><a href="#单向加密的功能" class="headerlink" title="单向加密的功能"></a>单向加密的功能</h4><p>验证数据的完整性。</p>
<h4 id="单向加密的算法"><a href="#单向加密的算法" class="headerlink" title="单向加密的算法"></a>单向加密的算法</h4><ul>
<li>md5: Message Digest 5, 128bits</li>
<li>sha1: Secure Hash Algorithm 1, 160bits</li>
<li>sha224</li>
<li>sha256</li>
<li>sha384</li>
<li>sha512</li>
</ul>
<h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><p>IKE（Internet Key Exchange）</p>
<h4 id="密钥交换的类型"><a href="#密钥交换的类型" class="headerlink" title="密钥交换的类型"></a>密钥交换的类型</h4><ul>
<li>公钥加密</li>
<li>DH（迪菲-赫尔曼</li>
<li>ECDH（椭圆曲线 DH）</li>
<li>ECDHE（临时椭圆曲线 DH）</li>
</ul>
<h2 id="openSSL-的组成"><a href="#openSSL-的组成" class="headerlink" title="openSSL 的组成"></a>openSSL 的组成</h2><ul>
<li>libencrypto 库</li>
<li>libssl 库</li>
<li>openssl 多用途命令行工具</li>
</ul>
<h2 id="SSL-会话主要步骤"><a href="#SSL-会话主要步骤" class="headerlink" title="SSL 会话主要步骤"></a>SSL 会话主要步骤</h2><ul>
<li>客户端向服务器端索要并验正证书</li>
<li>双方协商生成“会话密钥”</li>
<li>双方采用“会话密钥”进行加密通信</li>
</ul>
<h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><p>公钥基础设施，Public Key Infrastructure。</p>
<h3 id="PKI-的组成"><a href="#PKI-的组成" class="headerlink" title="PKI 的组成"></a>PKI 的组成</h3><ul>
<li>签证机构: CA</li>
<li>注册机构: RA</li>
<li>证书吊销列表: CRL</li>
<li>证书存取库</li>
</ul>
<h2 id="证书申请及签署步骤"><a href="#证书申请及签署步骤" class="headerlink" title="证书申请及签署步骤"></a>证书申请及签署步骤</h2><ol>
<li>生成申请请求</li>
<li>RA 核验</li>
<li>CA 签署</li>
<li>获取证书</li>
</ol>
<h2 id="建立私有-CA"><a href="#建立私有-CA" class="headerlink" title="建立私有 CA"></a>建立私有 CA</h2><p>配置文件: /etc/pki/tls/openssl.cnf</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>首先，需要构建私有 CA，在确定配置为 CA 的服务上生成一个自签证书，并为 CA 提供所需要的目录及文件即可。</p>
<p>其次，要用到证书进行安全通信的服务器，需要向 CA 请求签署证书。</p>
<h4 id="为-CA-提供所需的目录及文件"><a href="#为-CA-提供所需的目录及文件" class="headerlink" title="为 CA 提供所需的目录及文件"></a>为 CA 提供所需的目录及文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -pv /etc/pki/CA/&#123;certs,crl,newcerts&#125;</span><br><span class="line">touch /etc/pki/CA/&#123;serial,index.txt&#125;</span><br><span class="line"><span class="built_in">echo</span> 01 &gt; /etc/pki/CA/serial</span><br></pre></td></tr></table></figure>

<h4 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">umask</span> 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096)</span><br></pre></td></tr></table></figure>

<h4 id="CA-生成自签证书"><a href="#CA-生成自签证书" class="headerlink" title="CA 生成自签证书"></a>CA 生成自签证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -new: 生成新证书签署请求</span></span><br><span class="line"><span class="comment"># -x509: 生成自签格式证书，专用于创建私有CA</span></span><br><span class="line"><span class="comment"># -key: 生成请求时用到的私有文件路径</span></span><br><span class="line"><span class="comment"># -days: 证书的有效期限，单位是day</span></span><br><span class="line"><span class="comment"># -out: 生成的请求文件路径，如果自签操作将直接生成签署过的证书</span></span><br><span class="line">openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pem</span><br></pre></td></tr></table></figure>

<h4 id="发证"><a href="#发证" class="headerlink" title="发证"></a>发证</h4><p>步骤: （以 httpd 为例）</p>
<ol>
<li><p>用到证书的主机生成私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /etc/httpd/ssl</span><br><span class="line"><span class="built_in">cd</span> /etc/httpd/ssl</span><br><span class="line">(<span class="built_in">umask</span> 077;openssl genrsa -out /etc/httpd/ssl/httpd.key 2048)</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成证书签署请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -key /etc/httpd/ssl/httpd.key -days 365 -out /etc/httpd/ssl/httpd.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>将请求通过可靠方式发送给 CA 主机</p>
</li>
<li><p>在 CA 主机上签署证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ca -<span class="keyword">in</span> /tmp/httpd.csr -days 365 -out /etc/pki/CA/certs/httpd.crt</span><br></pre></td></tr></table></figure>

<p>查看证书中的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> /etc/pki/CA/certs/httpd.crt -noout -serial -subject -text</span><br></pre></td></tr></table></figure>
</li>
<li><p>CA 签署证书后，将证书发还给请求者</p>
</li>
</ol>
<h4 id="吊销证书"><a href="#吊销证书" class="headerlink" title="吊销证书"></a>吊销证书</h4><p>步骤:</p>
<ol>
<li><p>客户端获取要吊销的证书的 serial（在使用证书的主机执行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> /etc/pki/CA/certs/httpd.crt -noout -serial -subject</span><br></pre></td></tr></table></figure>
</li>
<li><p>CA 主机吊销证书</p>
<p>先根据客户提交的 serial 和 subject 信息，对比其与本机数据库 index.txt 中存储的是否一致。</p>
<p>吊销:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem</span><br></pre></td></tr></table></figure>

<p>其中的 SERIAL 要换成证书真正的序列号。</p>
</li>
<li><p>生成吊销证书的吊销编号（第一次吊销证书时执行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 01 &gt; /etc/pki/CA/crlnumber</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新证书吊销列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ca -gencrl -out thisca.crl</span><br></pre></td></tr></table></figure>

<p>查看 crl 文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl crl -<span class="keyword">in</span> /PATH/FROM/CRL_FILE.crl -noout -text</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="openssl-命令"><a href="#openssl-命令" class="headerlink" title="openssl 命令"></a>openssl 命令</h2><h3 id="enc"><a href="#enc" class="headerlink" title="enc"></a>enc</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl enc -e -des3 -a -salt -<span class="keyword">in</span> fstab -out fstab.ciphertext</span><br><span class="line">openssl enc -d -des3 -a -salt -out fstab -<span class="keyword">in</span> fstab.ciphertext</span><br></pre></td></tr></table></figure>

<h3 id="dgst"><a href="#dgst" class="headerlink" title="dgst"></a>dgst</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl dgst -sha1 -out fstab.sha1 fstab</span><br></pre></td></tr></table></figure>

<h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl passwd -1 -salt roger.ink</span><br></pre></td></tr></table></figure>

<h3 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 <span class="variable">$num_of_char</span></span><br><span class="line">openssl rand -hex <span class="variable">$num_of_char</span></span><br></pre></td></tr></table></figure>

<h3 id="genrsa"><a href="#genrsa" class="headerlink" title="genrsa"></a>genrsa</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建私钥</span></span><br><span class="line">openssl genrsa -out rsakey.private 2048</span><br></pre></td></tr></table></figure>

<h3 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> rsakey.private -pubout -out rsakey.pub</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>docker和docker-compose的安装</title>
    <url>/2020/11/21/docker%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<hr>
<p><img src="/img/docker_installation_title.png" alt="awk"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<p>docker 在各个平台上都提供了安装，下面记录一下各平台的安装方式。</p>
<a id="more"></a>

<h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><p>windows 和 macos 下安装 docker，可以直接下载官网的社区版进行安装。企业版强调安全性，是需要付费的。</p>
<p>ubuntu 下安装 docker，可以直接使用 apt 进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y docker.io</span><br></pre></td></tr></table></figure>

<p>centos 下安装 docker，可以获取 docker 官网的脚本，并修改源为阿里云，以便加速安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>

<p>安装完成后，设置开机启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<p>接着启动 docker 进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>然后创建 docker 组，并将当前用户加入到这个组中，获取 docker 的权限，不然每次使用 docker 命令都需要加上 sudo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<p>为了加快拉取 docker 镜像的速度，接下来修改 docker 的镜像源。使用中科大或者阿里云的镜像源。阿里云的镜像地址需要到阿里云上注册账号，使用它的 docker 服务获取。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;&#x27;</span>|sudo tee /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>docker 中默认 detachKeys 的前缀为 ctrl+p，这会使得原本在命令行中使用 ctrl+p 出现冲突，所以需要修改为其它快捷键。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;detachKeys&quot;: &quot;ctrl-e,e&quot; &#125;&#x27;</span>&gt;~/.docker/config.json</span><br></pre></td></tr></table></figure>

<p>修改完成后，重启 docker 服务就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h2><p>windows 和 macos 在安装完 docker 后，docker-compose 就已经安装好了，无需额外安装。</p>
<p>ubuntu 下可以使用 apt 进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y docker-compose</span><br></pre></td></tr></table></figure>

<p>centos 下可以获取 docker-compose 的安装脚本进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; ~/docker-compose &amp;&amp; sudo mv ~/docker-compose /usr/bin &amp;&amp; chmod +x /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>macos</tag>
        <tag>docker</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>sed的基本使用</title>
    <url>/2020/11/03/sed%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/sed_title.jpg" alt="sed"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>sed 命令是利用脚本来处理文本文件。</p>
<p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<p>sed 在 man 手册中的介绍是 stream editor for filtering and transforming text。</p>
<a id="more"></a>

<h2 id="sed-的参数"><a href="#sed-的参数" class="headerlink" title="sed 的参数"></a>sed 的参数</h2><ul>
<li>-n 不输出模式空间中的内容至屏幕</li>
<li>-e script, –expression=script: 多点编辑</li>
<li>-f /PATH/TO/SED_SCRIPT_FILE: 每行一个编辑命令</li>
<li>-r –regexp-extended: 支持使用扩展正则表达式</li>
<li>-i [SUFFIX], –in-place[=SUFFIX]: 直接编辑原文件</li>
</ul>
<h3 id="sed-的地址"><a href="#sed-的地址" class="headerlink" title="sed 的地址"></a>sed 的地址</h3><ul>
<li>空地址: 对全文进行处理</li>
<li>单地址:<ul>
<li>line_number: 指定行</li>
<li>/pattern/: 被此模式所匹配到的每一行</li>
</ul>
</li>
<li>地址范围<ul>
<li>line_number1,line_number2:</li>
<li>line_number,+num_of_lines:</li>
<li>line_number，/pattern/</li>
<li>/pattern1/,/pattern2/</li>
<li>$: 最后一行</li>
</ul>
</li>
<li>步进: ~<ul>
<li>1~2:所有奇数行</li>
<li>2~2:所有偶数行</li>
</ul>
</li>
</ul>
<h3 id="sed-的命令"><a href="#sed-的命令" class="headerlink" title="sed 的命令"></a>sed 的命令</h3><ul>
<li>d: 删除</li>
<li>p: 显示模式空间中的内容</li>
<li>a \text: 在行后面追加文本“text”，支持使用\n 实现多行追加</li>
<li>i \text: 在行前面插入文本“text”，支持使用\n 实现多行插入</li>
<li>c \text: 把匹配到的行替换为此处指定的文本“text”</li>
<li>w /PATH/TO/SOMEFILE: 保存模式空间匹配到的行至指定的文件中</li>
<li>r /PATH/FROM/SOMEFILE: 读取指定文件的内容至当前文件被模式匹配到的行后面，文件合并</li>
<li>=: 为模式匹配到的行打印行号</li>
<li>!: 条件取反，/pattern/!d，除了 pattern 之外的行都删除</li>
<li>s///: 查找替换，其分隔符可自行指定，常用的有 s@@@, s###等<ul>
<li>替换标记:<ul>
<li>g: 全局替换</li>
<li>w /PATH/TO/SOMEFILE: 将替换成功的结果保存至指定文件中</li>
<li>p: 显示替换成功的行</li>
</ul>
</li>
<li>&amp;: sed ‘s/int/&amp;eger/g’ path_to_file</li>
</ul>
</li>
</ul>
<h2 id="sed-的高级使用"><a href="#sed-的高级使用" class="headerlink" title="sed 的高级使用"></a>sed 的高级使用</h2><ul>
<li>h: 把模式空间中的内容覆盖至保持空间中</li>
<li>H: 把模式空间中的内容追加至保持空间中</li>
<li>g: 把保持空间中的内容覆盖至模式空间中</li>
<li>G: 把保持空间中的内容追加至模式空间中</li>
<li>x: 把模式空间中的内容与保持空间中的内容互换</li>
<li>n: 覆盖读取匹配到的行的下一行至模式空间中</li>
<li>N: 追加读取匹配到的行的下一行至模式空间中</li>
<li>d: 删除模式空间中的行</li>
<li>D: 删除多行模式空间中的所有行</li>
</ul>
<h2 id="sed-的示例"><a href="#sed-的示例" class="headerlink" title="sed 的示例"></a>sed 的示例</h2><h3 id="抑制模式空间的自动打印"><a href="#抑制模式空间的自动打印" class="headerlink" title="抑制模式空间的自动打印"></a>抑制模式空间的自动打印</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&quot;/<span class="variable">$pattern</span>/p&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed -n <span class="string">&quot;/<span class="variable">$pattern</span>/,/<span class="variable">$pattern</span>/p&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed -n <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>p&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed -n <span class="string">&quot;<span class="variable">$from_line_num</span>,<span class="variable">$&#123;to_line_num&#125;</span>p&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="删除包含匹配的行"><a href="#删除包含匹配的行" class="headerlink" title="删除包含匹配的行"></a>删除包含匹配的行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>d&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed <span class="string">&quot;/<span class="variable">$pattern</span>/d&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="插入和替换行"><a href="#插入和替换行" class="headerlink" title="插入和替换行"></a>插入和替换行</h3><h4 id="在匹配的行前面插入"><a href="#在匹配的行前面插入" class="headerlink" title="在匹配的行前面插入"></a>在匹配的行前面插入</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>a\ <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed <span class="string">&quot;/<span class="variable">$pattern</span>/a <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h4 id="在匹配的行后面插入"><a href="#在匹配的行后面插入" class="headerlink" title="在匹配的行后面插入"></a>在匹配的行后面插入</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>i\ <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed <span class="string">&quot;/<span class="variable">$pattern</span>/i\ <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h4 id="替换匹配的行"><a href="#替换匹配的行" class="headerlink" title="替换匹配的行"></a>替换匹配的行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>c\ <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed <span class="string">&quot;/<span class="variable">$pattern</span>/c\ <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="插入外部文件中的内容到指定位置"><a href="#插入外部文件中的内容到指定位置" class="headerlink" title="插入外部文件中的内容到指定位置"></a>插入外部文件中的内容到指定位置</h3><h4 id="每行插入"><a href="#每行插入" class="headerlink" title="每行插入"></a>每行插入</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;r <span class="variable">$file</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h4 id="指定行插入"><a href="#指定行插入" class="headerlink" title="指定行插入"></a>指定行插入</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>r <span class="variable">$file</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h4 id="从开始行到结束行之间都插入"><a href="#从开始行到结束行之间都插入" class="headerlink" title="从开始行到结束行之间都插入"></a>从开始行到结束行之间都插入</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$from_line_num</span>, <span class="variable">$&#123;to_line_num&#125;</span>r <span class="variable">$file</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="保存结果到新文件"><a href="#保存结果到新文件" class="headerlink" title="保存结果到新文件"></a>保存结果到新文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&quot;/<span class="variable">$pattern</span>/w <span class="variable">$new_file</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h4 id="每行替换"><a href="#每行替换" class="headerlink" title="每行替换"></a>每行替换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;s/<span class="variable">$pattern</span>/<span class="variable">$something</span>/g&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配后替换"><a href="#匹配后替换" class="headerlink" title="匹配后替换"></a>匹配后替换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;<span class="variable">$&#123;line_num&#125;</span>s/<span class="variable">$pattern</span>/<span class="variable">$something</span>/g&quot;</span> <span class="variable">$path_to_file</span></span><br><span class="line">sed <span class="string">&quot;/<span class="variable">$pattern</span>/s/<span class="variable">$pattern</span>/<span class="variable">$something</span>#gi&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="使用扩展的正则表达式"><a href="#使用扩展的正则表达式" class="headerlink" title="使用扩展的正则表达式"></a>使用扩展的正则表达式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -r /<span class="variable">$pattern</span>/p <span class="variable">$path_to_file</span></span><br><span class="line">sed -E /<span class="variable">$pattern</span>/p <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="对每行执行多次命令"><a href="#对每行执行多次命令" class="headerlink" title="对每行执行多次命令"></a>对每行执行多次命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&quot;1i <span class="variable">$something</span>&quot;</span> -e <span class="string">&quot;1a <span class="variable">$something</span>&quot;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="读取外部执行命令的文件来执行命令"><a href="#读取外部执行命令的文件来执行命令" class="headerlink" title="读取外部执行命令的文件来执行命令"></a>读取外部执行命令的文件来执行命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -f <span class="variable">$path_to_script_file</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="引用匹配后所有的部分使用-amp"><a href="#引用匹配后所有的部分使用-amp" class="headerlink" title="引用匹配后所有的部分使用&amp;"></a>引用匹配后所有的部分使用&amp;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/l..k/&amp;r/g&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="引用匹配后限定的部分使用-num"><a href="#引用匹配后限定的部分使用-num" class="headerlink" title="引用匹配后限定的部分使用\num"></a>引用匹配后限定的部分使用\num</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\(l..k\) this/\1r/g&#x27;</span> <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>grep的基本使用</title>
    <url>/2020/11/04/grep%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/grep_title.jpg" alt="grep"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>grep 命令用于查找文件里符合条件的字符串。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p>
<p>grep 在 man 手册中的介绍是 print lines that match patterns。</p>
<a id="more"></a>

<h2 id="grep-的示例"><a href="#grep-的示例" class="headerlink" title="grep 的示例"></a>grep 的示例</h2><h3 id="加入颜色区分匹配的内容"><a href="#加入颜色区分匹配的内容" class="headerlink" title="加入颜色区分匹配的内容"></a>加入颜色区分匹配的内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep --color <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="排除匹配的内容"><a href="#排除匹配的内容" class="headerlink" title="排除匹配的内容"></a>排除匹配的内容</h3><h4 id="排除单个"><a href="#排除单个" class="headerlink" title="排除单个"></a>排除单个</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -v <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h4 id="排除多个"><a href="#排除多个" class="headerlink" title="排除多个"></a>排除多个</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -vE <span class="string">&quot;<span class="variable">$something</span>|<span class="variable">$another</span>&quot;</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h4 id="排除空格"><a href="#排除空格" class="headerlink" title="排除空格"></a>排除空格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [^[:space:]] <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="对结果显示行号"><a href="#对结果显示行号" class="headerlink" title="对结果显示行号"></a>对结果显示行号</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -n <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="仅显示匹配的内容"><a href="#仅显示匹配的内容" class="headerlink" title="仅显示匹配的内容"></a>仅显示匹配的内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -o <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="递归搜索"><a href="#递归搜索" class="headerlink" title="递归搜索"></a>递归搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -R <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="仅显示匹配的文件名"><a href="#仅显示匹配的文件名" class="headerlink" title="仅显示匹配的文件名"></a>仅显示匹配的文件名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -l <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="静默搜索"><a href="#静默搜索" class="headerlink" title="静默搜索"></a>静默搜索</h3><p>用于只需要执行正确与否的结果时。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -q <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="锚定单词"><a href="#锚定单词" class="headerlink" title="锚定单词"></a>锚定单词</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;\&lt;world\&gt;&#x27;</span> <span class="variable">$path</span></span><br><span class="line">grep <span class="string">&#x27;\bworld\b&#x27;</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h3 id="显示匹配的内容前后部分"><a href="#显示匹配的内容前后部分" class="headerlink" title="显示匹配的内容前后部分"></a>显示匹配的内容前后部分</h3><h4 id="显示匹配的内容后几行"><a href="#显示匹配的内容后几行" class="headerlink" title="显示匹配的内容后几行"></a>显示匹配的内容后几行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -A <span class="variable">$num_of_lines</span> <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h4 id="显示匹配的内容前几行"><a href="#显示匹配的内容前几行" class="headerlink" title="显示匹配的内容前几行"></a>显示匹配的内容前几行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -B <span class="variable">$num_of_lines</span> <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<h4 id="显示匹配的内容前后各几行"><a href="#显示匹配的内容前后各几行" class="headerlink" title="显示匹配的内容前后各几行"></a>显示匹配的内容前后各几行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -C <span class="variable">$num_of_lines</span> <span class="variable">$something</span> <span class="variable">$path</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>unity的特殊路径</title>
    <url>/2020/11/20/unity%E7%9A%84%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p><img src="/img/unity_path_title.jpg" alt="sed"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unity中特殊文件夹，是比较容易混淆的，在此记录一下。</p>
<a id="more"></a>

<h2 id="StreamingAssetsPath"><a href="#StreamingAssetsPath" class="headerlink" title="StreamingAssetsPath"></a>StreamingAssetsPath</h2><p>StreamingAssets 目录必须在 Assets 根目录下，该目录下所有资源会被打包到游戏里，该目录下的资源不会进行压缩，不加密，是只读不可写的。</p>
<h3 id="StreamingAssetsPath-的访问方式"><a href="#StreamingAssetsPath-的访问方式" class="headerlink" title="StreamingAssetsPath 的访问方式"></a>StreamingAssetsPath 的访问方式</h3><p>Unity Editor, Windows, Linux players, PS4, Xbox One, Switch</p>
<ul>
<li>Application.dataPath + “/StreamingAssets”</li>
<li>Application.streamingAssetsPath</li>
</ul>
<p>macOS</p>
<ul>
<li>Application.dataPath + “/Resources/Data/StreamingAssets”</li>
</ul>
<p>iOS</p>
<ul>
<li>Application.dataPath + “/Raw”</li>
</ul>
<p>android</p>
<ul>
<li>“jar:file://“ + Application.dataPath + “!/assets”</li>
</ul>
<h2 id="PersistentDataPath"><a href="#PersistentDataPath" class="headerlink" title="PersistentDataPath"></a>PersistentDataPath</h2><p>该目录为应用程序沙盒目录，应用程序安装后才会出现。该目录是可读可写的，所以我们一般将运行时下载的资源存放于此。</p>
<h3 id="PersistentDataPath-的访问方式"><a href="#PersistentDataPath-的访问方式" class="headerlink" title="PersistentDataPath 的访问方式"></a>PersistentDataPath 的访问方式</h3><ul>
<li>Application.persistentDataPath</li>
</ul>
<h2 id="DataPath"><a href="#DataPath" class="headerlink" title="DataPath"></a>DataPath</h2><p>应用程序目录，即 Assets 目录。</p>
<h3 id="DataPath-的访问方式"><a href="#DataPath-的访问方式" class="headerlink" title="DataPath 的访问方式"></a>DataPath 的访问方式</h3><ul>
<li>Appliction.dataPath</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>Resources 文件夹可以在根目录下，也可以在子目录下，只要叫 Resources 就好。Resources 目录下所有资源将被压缩加密打包进游戏中，该目录下所有资源会被压缩，加密，只读不可写，在运行时 Resources 目录在应用中也就不复存在，但加载时仍使用曾在 Resource 下的路径。</p>
<h3 id="Resources-的访问方式"><a href="#Resources-的访问方式" class="headerlink" title="Resources 的访问方式"></a>Resources 的访问方式</h3><ul>
<li>Resources.Load()</li>
</ul>
<h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><p>Editor 文件夹可以在根目录下，也可以在子目录下，只要叫 Editor 就好。</p>
<p>不会被打包，只能在unity的编辑器中使用。</p>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>Plugin 文件夹可以在根目录下，也可以在子目录下，只要叫 Plugin 就好。</p>
<p>会被打包，用来存放插件，jar包和第三方的SDK等。</p>
<h2 id="各平台对应的地址"><a href="#各平台对应的地址" class="headerlink" title="各平台对应的地址"></a>各平台对应的地址</h2><h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>Application.dataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</p>
<p>Application.streamingAssetsPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</p>
<p>Application.persistentDataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</p>
<p>Application.temporaryCachePath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>Application.dataPath : /data/app/xxx.xxx.xxx.apk</p>
<p>Application.streamingAssetsPath : jar:file:///data/app/xxx.xxx.xxx.apk/!/assets</p>
<p>Application.persistentDataPath : /data/data/xxx.xxx.xxx/files</p>
<p>Application.temporaryCachePath : /data/data/xxx.xxx.xxx/cache</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Application.dataPath : /Assets</p>
<p>Application.streamingAssetsPath : /Assets/StreamingAssets</p>
<p>Application.persistentDataPath : C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductName</p>
<p>Application.temporaryCachePath : C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Application.dataPath : /Assets</p>
<p>Application.streamingAssetsPath : /Assets/StreamingAssets</p>
<p>Application.persistentDataPath : /Users/xxxx/Library/Caches/CompanyName/Product Name</p>
<p>Application.temporaryCachePath : /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product Name</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>wget的基本使用</title>
    <url>/2020/11/15/wget%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/wget_title.jpg" alt="wget"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>wget - the non-interactive network downloader</p>
<p>wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP 协议 下载，并可以使用 HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。</p>
<p>所谓自动下载，是指 wget 可以在用户退出系统的之后在继续后台执行，直到下载任务完成。</p>
<a id="more"></a>

<h2 id="wget-的示例"><a href="#wget-的示例" class="headerlink" title="wget 的示例"></a>wget 的示例</h2><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="获取内容"><a href="#获取内容" class="headerlink" title="获取内容"></a>获取内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类似 curl $url</span></span><br><span class="line">wget -O - -q <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="下载文件另存为本地某个文件"><a href="#下载文件另存为本地某个文件" class="headerlink" title="下载文件另存为本地某个文件"></a>下载文件另存为本地某个文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O <span class="variable">$path_to_file</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="保存日志"><a href="#保存日志" class="headerlink" title="保存日志"></a>保存日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -o <span class="variable">$log_url</span> <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="静默模式"><a href="#静默模式" class="headerlink" title="静默模式"></a>静默模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -b <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -c <span class="variable">$url</span></span><br></pre></td></tr></table></figure>

<h3 id="读取本地文件中的-url-作为输入"><a href="#读取本地文件中的-url-作为输入" class="headerlink" title="读取本地文件中的 url 作为输入"></a>读取本地文件中的 url 作为输入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -i <span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>

<h3 id="递归模式"><a href="#递归模式" class="headerlink" title="递归模式"></a>递归模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -r <span class="variable">$url</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>macos</tag>
        <tag>wget</tag>
      </tags>
  </entry>
  <entry>
    <title>用VSCode在容器中调试js</title>
    <url>/2020/11/03/%E7%94%A8VSCode%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%B0%83%E8%AF%95js/</url>
    <content><![CDATA[<p><img src="/img/debug_js_title.png" alt="debug js"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 VSCode 的容器中，调试是比较麻烦的。主要是容器内外的端口需要映射，浏览器能正常连接后才能进行调试。根据调试的对象不同，方式也不尽相同。下面分别来进行说明。</p>
<a id="more"></a>

<h2 id="调试-Node-js"><a href="#调试-Node-js" class="headerlink" title="调试 Node.js"></a>调试 Node.js</h2><p>用 VSCode 进入容器后，打开调试面板，点击面板上方的设置按钮后，会打开 launch.json 配置文件，在该文件中进行如下设置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Node.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;skipFiles&quot;</span>: [<span class="string">&quot;&lt;node_internals&gt;/**&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/server.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的各个参数说明如下:</p>
<ul>
<li>version: 配置文件的版本号。</li>
<li>configurations: 配置调试器的地方，可配置多个。</li>
<li>type: 表示调试的是 Node.js 代码。</li>
<li>request: 表示每次启动调试的方式。<ul>
<li>lauch: 会重新启动一个 Node.js 进程来进行调试。</li>
<li>attach: 会附加到一个已经存在的 Node.js 进程来进行调试。</li>
</ul>
</li>
<li>name: 调试配置的名字。</li>
<li>skipFiles: 忽略掉不需要进行调试的文件。</li>
<li>program: 启动调试后，程序的入口文件。</li>
</ul>
<p>设置完成后，用 VSCode 在容器中需要调试的地方打上断点，然后启动调试，用浏览器进行访问。如果没有问题，就可以看到程序已经停止在了断点处了。</p>
<p><img src="/img/debug_nodejs_result.png" alt="最终调试结果"></p>
<h2 id="调试普通-javascript-代码"><a href="#调试普通-javascript-代码" class="headerlink" title="调试普通 javascript 代码"></a>调试普通 javascript 代码</h2><p>在容器中调试 javascript，需要先在容器中安装 Debug for chrome 和 live server 两个插件。</p>
<p><img src="/img/live_server.png" alt="live server"></p>
<p><strong>重要</strong>: 由于我们调试的是容器中的应用，因此需要在容器启动的时候将容器中 live server 的端口映射出来。</p>
<p><img src="/img/debug_for_chrome.png" alt="debug for chrome"></p>
<p>如果对 live server 插件不熟悉，可以参考另外一篇关于 live server 的介绍。<br>首先启动 live server 插件。然后打开 launch.json 配置文件，在该插件中进行如下设置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Chrome&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://localhost:5500/public/show.html&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的参数是 url 的设置。它指向的是容器中的单个 html 文件。</p>
<p>设置完成后，在需要调试的地方打上断点，然后启动调试，用浏览器进行访问。如果没有问题，就可以看到程序已经停止在了断点处了。</p>
<p><img src="/img/debug_js_result.png" alt="最终调试结果"></p>
<p>以上就是在容器中调试的内容了，更多关于在 vscode 中的调试技术，请参考<a href="https://github.com/microsoft/vscode-recipes">vscode-recipes</a>、<a href="https://www.freecodecamp.org/news/node-js-debugging/">node-js-debugging</a>和<a href="https://github.com/GoogleChromeLabs/ndb">ndb</a>。另外，在文中提到的 live server 是个很不错的插件，它同时也是一个结合浏览器实时查看开发效果的神器。关于它的介绍，请参考<a href="https://roger.ink/2020/11/03/%E7%94%A8live-server%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E6%95%88%E6%9E%9C/">用 live server 实时查看容器中的开发效果</a>。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>用live server实时查看容器中的开发效果</title>
    <url>/2020/11/03/%E7%94%A8live-server%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p><img src="/img/live_server_title.png" alt="live server"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 web 前端的开发过程中，经常会手动修改了一段代码之后需要立刻查看效果的时候。于是切换到浏览器，然后刷新网页进行查看。这个过程其实还可以更无缝的实现。</p>
<p>live server 就是一款实时查看开发的 web 效果的插件。当你修改了 web 前端后，live server 会自动刷新并及时反映出目前 web 的效果。那么如果我们是在容器中开发项目呢，下面我们就来看看如何实现。</p>
<a id="more"></a>

<h2 id="安装和使用-live-server-插件"><a href="#安装和使用-live-server-插件" class="headerlink" title="安装和使用 live server 插件"></a>安装和使用 live server 插件</h2><p>live server 插件的安装方式非常简单。在 VSCode 中的扩展中搜索到 live server 插件后选择安装即可。</p>
<p><img src="/img/live_server.png" alt="live server"></p>
<p>安装完成后，我们来启动 live server 插件。</p>
<p>在 VSCode 的右下角，点击 Go Live 的图标启动服务。该插件默认会监听 5500 端口。</p>
<p><img src="/img/live_server_start.jpg" alt="start live server"></p>
<p>这时可以打开浏览器，输入需要查看的网址，也可以对 VSCode 文件管理器中的文件右键，选择用 live server 打开，然后在 VSCode 中更改选择的文件代码吧，你会发现，浏览器中内容也在不断更新以实时反映开发效果。</p>
<p><img src="/img/live_server_open.jpg" alt="open live server"></p>
<p>最终效果如下:</p>
<p><img src="/img/live_server_result.gif" alt="open live server"></p>
<h2 id="在容器中使用-live-server"><a href="#在容器中使用-live-server" class="headerlink" title="在容器中使用 live server"></a>在容器中使用 live server</h2><p>在容器中使用 live server，需要先在容器中安装 live server。</p>
<p>由于我们调试的是容器中的应用，因此需要在容器启动的时候将容器中 live server 的端口映射出来。容器中的 live server 默认监听的端口是 5500，因此需要将 5500 端口映射出来。</p>
<p><img src="/img/live_server_exports.png" alt="映射端口"></p>
<p>上图中，我的 web 服务器端口是 3000，live server 端口是 5500。</p>
<p>映射端口完成后，点击 VSCode 右下角 Go Live 按钮开启服务。 不过这时只能通过 live server 的 5500 端口观察到实时的效果。如果希望通过 3000 端口观察的话，需要额外安装 live server web extension 插件。</p>
<p><img src="/img/live_server_web_extension.png" alt="live server web extension"></p>
<p>live server web extension 可以让 PHP，.NET 和 Node.js 中的代码一样的工作在 live server 的实时观察模式下。</p>
<p><a href="https://github.com/ritwickdey/live-server-web-extension">live server web extension</a></p>
<p>安装完成后，在浏览器中打开该插件，在该插件中进行如下设置。</p>
<p><img src="/img/live_server_web_extension_chrome.png" alt="alt"></p>
<p>其中的各个设置说明如下:</p>
<ul>
<li>Live Reload: 打开或关闭实时查看功能。</li>
<li>I don’t want proxy setup(recommended): 是否不使用代理功能。</li>
<li>Actual Server Address: 需要调试的服务器的地址。</li>
<li>Live Server Address: live server 服务的地址。</li>
</ul>
<p>在 Actual Server Address 和 live Server Address 中填入合适的地址后，点击 Apply 就应用成功了。</p>
<p>设置完成后，打开浏览器，输入需要查看的网址，然后在 VSCode 中更改选择的文件代码吧，你会发现，浏览器中内容也在不断更新以实时反映开发效果。</p>
<p>以上就是 live server 的基本使用方式和在容器中的使用方式。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>交换capslock和control键位</title>
    <url>/2020/11/04/%E4%BA%A4%E6%8D%A2capslock%E5%92%8Ccontrol%E9%94%AE%E4%BD%8D/</url>
    <content><![CDATA[<p><img src="/img/modify_keys_title.png" alt="modify_key"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对于使用 vim 和 emacs 的朋友来说，交换 capslock 和 control 的键位对于自己的习惯来说是至关重要的。那么如何设置才能交换呢，对于不同的操作系统有不同的方法。</p>
<a id="more"></a>

<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>在 windows 系统中，最简便的方式是使用 KeyTweak 这款软件。</p>
<p><img src="/img/windows_modify_keys.png" alt="KeyTweak"></p>
<p>另外有些笔记本自带有一些键位设置的软件。比如微星的 MSI PER KEY RGB KEYBOARD 软件就可以在系统级别进行设置。</p>
<h2 id="macos"><a href="#macos" class="headerlink" title="macos"></a>macos</h2><p>在 macos 系统中，进入系统设置，键盘，修改键位就可以了。</p>
<p><img src="/img/macos_modify_keys.png" alt="macos"></p>
<p>另外推荐一款修改键位的神器，<a href="https://karabiner-elements.pqrs.org/">Karabiner-Elements</a>，喜欢修改键位的朋友不要错过。</p>
<h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><p>在 ubuntu 系统中，修改/etc/default/keyboard 文件，设置 XKBOPTIONS=”ctrl:nocaps”即可。</p>
<p><img src="/img/ubuntu_modify_keys.png" alt="ubuntu"></p>
<h2 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h2><p>在 centos 系统中，新建 swap_ctrl_capslock.kmap 文件，在文件中写入如下代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keymaps 0-127</span><br><span class="line">keycode 58=Control</span><br></pre></td></tr></table></figure>

<p>然后在命令行中执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo loadkeys swap_ctrl_capslock.kmap</span><br></pre></td></tr></table></figure>

<p><img src="/img/centos_modify_keys.png" alt="centos"></p>
<p>如需每次开机自动生效，可以将该指令写入~/.bashrc 文件中。</p>
<p>由于该指令需要 root 权限，如果不是以 root 用户身份登陆，需要在/etc/sudoer 中写入 NOPASSWD 以免输入密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span> ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>macos</tag>
        <tag>windows</tag>
        <tag>keyboard</tag>
        <tag>ubuntu</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>openssh的基本应用</title>
    <url>/2020/11/05/openssh%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><img src="/img/openssh_title.png" alt="openssl"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH 协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如 telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh 都是极为不安全的，并且会使用明文传送密码。OpenSSH 提供了服务端后台程序和客户端工具，用来加密远程控制和文件传输过程中的数据，并由此来代替原来的类似服务。</p>
<p>OpenSSH 是使用 SSH 透过计算机网络加密通讯的实现。它是取代由 SSH Communications Security 所提供的商用版本的开放源代码方案。目前 OpenSSH 是 OpenBSD 的子计划。</p>
<p>OpenSSH 常常被误认以为与 OpenSSL 有关联，但实际上这两个计划的有不同的目的，不同的发展团队，名称相近只是因为两者有同样的软件发展目标 ── 提供开放源代码的加密通讯软件。</p>
<a id="more"></a>

<h2 id="sshd-config-的说明"><a href="#sshd-config-的说明" class="headerlink" title="sshd_config 的说明"></a>sshd_config 的说明</h2><table>
<thead>
<tr>
<th>字段</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Protocol</td>
<td>2</td>
<td>新版本在默认情况下，使用的是 protocol 2。如果旧版本默认情况下使用的是 protocol 1，需要在配置文件中加入 Protocol 2。</td>
</tr>
<tr>
<td>Port</td>
<td>22</td>
<td>监听的端口号。</td>
</tr>
<tr>
<td>AddressFamily</td>
<td>any</td>
<td>地址族 “any”(默认)、”inet”(仅 IPv4)、”inet6”(仅 IPv6)。</td>
</tr>
<tr>
<td>ListenAddress</td>
<td>0.0.0.0</td>
<td>IPv4 监听所有地址。</td>
</tr>
<tr>
<td>ListenAddress</td>
<td>::</td>
<td>IPv6 监听所有地址。</td>
</tr>
<tr>
<td>HostKey</td>
<td>/etc/ssh/ssh_host_rsa_key</td>
<td>主机私钥文件的位置。</td>
</tr>
<tr>
<td>HostKey</td>
<td>/etc/ssh/ssh_host_ecdsa_key</td>
<td>主机私钥文件的位置。</td>
</tr>
<tr>
<td>HostKey</td>
<td>/etc/ssh/ssh_host_ed25519_key</td>
<td>主机私钥文件的位置。</td>
</tr>
<tr>
<td>RekeyLimit</td>
<td>default none</td>
<td></td>
</tr>
<tr>
<td>SyslogFacility</td>
<td>AUTH</td>
<td>日志消息通过哪个日志子系统(facility)发送，有效值有 DAEMON, USER, AUTH(默认), LOCAL0, LOCAL1, LOCAL2, LOCAL3, LOCAL4, LOCAL5, LOCAL6, LOCAL7。在 centos 中，记录在/var/log/secure，在 ubuntu 中，记录在/var/log/auth.log。</td>
</tr>
<tr>
<td>LogLevel</td>
<td>INFO</td>
<td>日志等级，有效值有 QUIET, FATAL, ERROR, INFO(默认), VERBOSE, DEBUG, DEBUG1, DEBUG2, DEBUG3。</td>
</tr>
<tr>
<td>LoginGraceTime</td>
<td>2m</td>
<td>限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。</td>
</tr>
<tr>
<td>PermitRootLogin</td>
<td>prohibit-password</td>
<td>是否允许 root 登录。可用值如下:”yes”(默认) 表示允许。”no”表示禁止。”prohibit-password”表示允许 root 登陆，但禁止其使用密码认证登录。</td>
</tr>
<tr>
<td>StrictModes</td>
<td>yes</td>
<td>严格检查模式，在接受连接请求前对用户主目录和相关的配置文件进行宿主和权限检查。</td>
</tr>
<tr>
<td>MaxAuthTries</td>
<td>6</td>
<td>每个连接最大允许的认证次数，比如输入密码错误次数。</td>
</tr>
<tr>
<td>MaxSessions</td>
<td>10</td>
<td>每个连接可以并行开启多少个会话。</td>
</tr>
<tr>
<td>PubkeyAuthentication</td>
<td>yes</td>
<td>是否允许公钥认证。</td>
</tr>
<tr>
<td>AuthorizedKeysFile</td>
<td>.ssh/authorized_keys .ssh/authorized_keys2</td>
<td>存放该用户可以用来登录的公钥位置。</td>
</tr>
<tr>
<td>AuthorizedPrincipalsFile</td>
<td>none</td>
<td></td>
</tr>
<tr>
<td>AuthorizedKeysCommand</td>
<td>none</td>
<td></td>
</tr>
<tr>
<td>AuthorizedKeysCommandUser</td>
<td>nobody</td>
<td></td>
</tr>
<tr>
<td>HostbasedAuthentication</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>IgnoreUserKnownHosts</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>IgnoreRhosts</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>PasswordAuthentication</td>
<td>yes</td>
<td>是否允许使用基于密码的认证。默认为”yes”。</td>
</tr>
<tr>
<td>PermitEmptyPasswords</td>
<td>no</td>
<td>是否允许密码为空的用户远程登录。默认为”no”。</td>
</tr>
<tr>
<td>ChallengeResponseAuthentication</td>
<td>no</td>
<td>是否允许质疑-应答(challenge-response)认证。默认值是”yes”。一般关闭，不安全。</td>
</tr>
<tr>
<td>KerberosAuthentication</td>
<td>no</td>
<td>是否要求用户为 PasswordAuthentication 提供的密码必须通过 Kerberos KDC 认证，也就是是否使用 Kerberos 认证。大规模统一认证的时候使用。</td>
</tr>
<tr>
<td>KerberosOrLocalPasswd</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>KerberosTicketCleanup</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>KerberosGetAFSToken</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>GSSAPIAuthentication</td>
<td>no</td>
<td>是否允许使用基于 GSSAPI 的用户认证。默认值为”no”。</td>
</tr>
<tr>
<td>GSSAPICleanupCredentials</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>GSSAPIStrictAcceptorCheck</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>GSSAPIKeyExchange</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>UsePAM</td>
<td>yes</td>
<td>是否启用 PAM 认证。</td>
</tr>
<tr>
<td>AllowAgentForwarding</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>AllowTcpForwarding</td>
<td>yes</td>
<td>是否允许 TCP 转发，默认值为”yes”。</td>
</tr>
<tr>
<td>GatewayPorts</td>
<td>no</td>
<td>是否允许远程主机连接本地的转发端口。默认值是”no”。</td>
</tr>
<tr>
<td>X11Forwarding</td>
<td>yes</td>
<td>是否允许进行 X11 转发。默认值是”no”，设为”yes”表示允许。需要在客户端连接时加入-X 选项。</td>
</tr>
<tr>
<td>X11DisplayOffset</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>X11UseLocalhost</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>PermitTTY</td>
<td>yes</td>
<td></td>
</tr>
<tr>
<td>PrintMotd</td>
<td>no</td>
<td>是否在每一次交互式登录时打印/etc/motd 文件的内容。默认值是”yes”。</td>
</tr>
<tr>
<td>PrintLastLog</td>
<td>yes</td>
<td>是否在每一次交互式登录时打印最后一位用户的登录时间。默认值是”yes”。</td>
</tr>
<tr>
<td>TCPKeepAlive</td>
<td>yes</td>
<td>系统是否向客户端发送 TCP keepalive 消息。默认值是”yes”。</td>
</tr>
<tr>
<td>PermitUserEnvironment</td>
<td>no</td>
<td>是否允许处理<del>/.ssh/environment 以及</del>/.ssh/authorized_keys 中的 environment=选项。默认值是”no”。如果设为”yes”可能会导致用户有机会使用某些机制(比如 LD_PRELOAD)绕过访问控制，造成安全漏洞。</td>
</tr>
<tr>
<td>Compression</td>
<td>delayed</td>
<td>是否对通信数据进行加密，还是延迟到认证成功之后再对通信数据加密。可用值:”yes”, “delayed”(默认), “no”。</td>
</tr>
<tr>
<td>ClientAliveInterval</td>
<td>0</td>
<td>设置一个以秒记的时长，如果超过这么长时间没有收到客户端的任何数据，将通过安全通道向客户端发送一个”alive”消息，并等候应答。默认值为 0，表示不发送”alive”消息。</td>
</tr>
<tr>
<td>ClientAliveCountMax</td>
<td>3</td>
<td>在未收到任何客户端回应前最多允许发送多少个”alive”消息。默认值是 3。到达这个上限后，将强制断开连接、关闭会话。</td>
</tr>
<tr>
<td>UseDNS</td>
<td>no</td>
<td>是否应该对远程主机名进行反向解析，以检查此主机名是否与其 IP 地址真实对应。默认值为”yes”。</td>
</tr>
<tr>
<td>PidFile</td>
<td>/var/run/sshd.pid</td>
<td>在哪个文件中存放 SSH 守护进程的进程号，默认为/var/run/sshd.pid 文件。</td>
</tr>
<tr>
<td>MaxStartups</td>
<td>10:30:100</td>
<td>10:当连接数达到 10 时就开始拒绝连接，不过不是全部拒绝。30:当连接数到达 10 时，之后的连接有 30 的概率被拒绝掉。100:当连接数达到 100 时，之后的连接就全部拒绝了。可以直接设置为 10，达到 10 后就不能连接了。</td>
</tr>
<tr>
<td>PermitTunnel</td>
<td>no</td>
<td>是否允许 tun(4)设备转发。可用值为:”yes”, “point-to-point”(layer 3), “ethernet”(layer 2), “no”(默认)。”yes”同时蕴含着”point-to-point”和”ethernet”。</td>
</tr>
<tr>
<td>ChrootDirectory</td>
<td>none</td>
<td></td>
</tr>
<tr>
<td>VersionAddendum</td>
<td>none</td>
<td></td>
</tr>
<tr>
<td>Banner</td>
<td>none</td>
<td>将指定的文件中的内容在用户进行认证前显示给远程用户。</td>
</tr>
<tr>
<td>AcceptEnv</td>
<td>LANG LC_*</td>
<td>指定客户端发送的哪些环境变量将会被传递到会话环境中。</td>
</tr>
<tr>
<td>Subsystem</td>
<td>sftp /usr/lib/openssh/sftp-server</td>
<td>配置一个外部子系统(例如，一个文件传输守护进程)。值是一个子系统的名字和对应的命令行(含选项和参数)。比如”sftp /usr/lib/openssh/sftp-server”。</td>
</tr>
<tr>
<td>AllowUsers</td>
<td></td>
<td>这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*“和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么将仅允许这些用户登录，而拒绝其它所有用户。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。例如:AllowUsers <a href="mailto:&#97;&#x64;&#109;&#105;&#x6e;&#x40;&#49;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#46;&#49;">&#97;&#x64;&#109;&#105;&#x6e;&#x40;&#49;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#x30;&#46;&#49;</a>。指定多用户用空格:AllowUsers <a href="mailto:&#97;&#100;&#x6d;&#105;&#110;&#64;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#x2e;&#x30;&#46;&#x31;">&#97;&#100;&#x6d;&#105;&#110;&#64;&#49;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#x2e;&#x30;&#46;&#x31;</a> user1</td>
</tr>
<tr>
<td>AllowGroups</td>
<td></td>
<td>这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*“和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么将仅允许这些组中的成员登录，而拒绝其它所有组。这里的”组”是指”主组”(primary group)，也就是/etc/passwd 文件中指定的组。</td>
</tr>
<tr>
<td>DenyUsers</td>
<td></td>
<td>这个指令后面跟着一串用空格分隔的用户名列表(其中可以使用”*“和”?”通配符)。默认允许所有用户登录。如果使用了这个指令，那么这些用户将被拒绝登录。如果指定了 USER@HOST 模式的用户，那么 USER 和 HOST 将同时被检查。</td>
</tr>
<tr>
<td>DenyGroups</td>
<td></td>
<td>这个指令后面跟着一串用空格分隔的组名列表(其中可以使用”*“和”?”通配符)。默认允许所有组登录。如果使用了这个指令，那么这些组中的成员将被拒绝登录。这里的”组”是指”主组”(primary group)，也就是/etc/passwd 文件中指定的组。</td>
</tr>
<tr>
<td>Match</td>
<td>User anoncvs</td>
<td>引入一个条件块。块的结尾标志是另一个 Match 指令或者文件结尾。如果 Match 行上指定的条件都满足，那么随后的指令将覆盖全局配置中的指令。Match 的值是一个或多个”条件-模式”对。可用的”条件”是:User,Group,Host,Address。</td>
</tr>
</tbody></table>
<h2 id="ssh-服务的最佳实践"><a href="#ssh-服务的最佳实践" class="headerlink" title="ssh 服务的最佳实践"></a>ssh 服务的最佳实践</h2><ul>
<li><p>不要使用默认端口</p>
</li>
<li><p>禁止使用 protocol version 1</p>
</li>
<li><p>限制可登录的用户</p>
</li>
<li><p>设定空闲会话超时时长</p>
</li>
<li><p>利用防火墙设置 ssh 访问策略</p>
</li>
<li><p>仅监听特定的 IP 地址</p>
</li>
<li><p>基于口令认证时，使用强密码策略</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tr -dc A-Za-z0-9\_ &lt; /dev/urandom | head -c 30 | xargs</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用基于密钥的认证</p>
</li>
<li><p>禁止使用空密码</p>
</li>
<li><p>禁止 root 用户直接登录</p>
</li>
<li><p>限制 ssh 的访问频度和并发在线数</p>
</li>
</ul>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -p port: 远程服务器监听的端口</span></span><br><span class="line"><span class="comment"># -X: 支持x11转发</span></span><br><span class="line"><span class="comment"># -Y: 支持信任的x11转发</span></span><br><span class="line">ssh <span class="variable">$username</span>@<span class="variable">$host</span></span><br></pre></td></tr></table></figure>

<h2 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h2 id="ssh-copy-id"><a href="#ssh-copy-id" class="headerlink" title="ssh-copy-id"></a>ssh-copy-id</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id <span class="variable">$username</span>@<span class="variable">$host</span></span><br></pre></td></tr></table></figure>

<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -r: 递归复制</span></span><br><span class="line"><span class="comment"># -p: 保持源文件的属性信息</span></span><br><span class="line"><span class="comment"># -q: 静默模式</span></span><br><span class="line"><span class="comment"># -P: host监听的端口</span></span><br><span class="line">scp <span class="variable">$username</span>@<span class="variable">$host</span>:<span class="variable">$path_to_file</span> <span class="variable">$path_to_file</span></span><br><span class="line">scp <span class="variable">$path_to_file</span> <span class="variable">$username</span>@<span class="variable">$host</span>:<span class="variable">$path_to_file</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>openssl</tag>
        <tag>openssh</tag>
      </tags>
  </entry>
</search>
